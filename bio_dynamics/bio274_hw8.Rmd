---
title: "BIOL 274 Homework 8"
author: "Ruby Krasnow"
date: "2024-04-06"
output:
  pdf_document:
    extra_dependencies: ["derivative", "tcolorbox", "xcolor"]
---
# Visualizing Solutions of Linear Systems and Runge-Kutta

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(phaseR)
library(demodelr)
library(deSolve)
```


## Question 1  
Consider the epidemic model presented in class.

### a.  
For the parameters given, we found one single equilibrium point. Determine whether this equilibrium point is stable or unstable and sketch the phase plane near the equilibrium point.


Let $X$ be the number of susceptible individuals at time $t$ and $Y$ be the number of infected individuals (who can transmit the disease). The epidemic model presented in class takes the following form:
$$\frac{dX}{dt}=-\mu XY+ \rho $$
$$\frac{dY}{dt}=\mu XY- \nu Y $$
where $\mu=0.025,\; \rho=5,$ and $\nu =0.5$. We determined that given these parameters, the model has a single equilibrium point at $\left( \frac{\nu}{\mu}, \frac{\rho}{\nu}\right)=(20,10)$.


We will determine the local stability of this equilibrium point by first computing the Jacobian matrix at $(20,10)$.

Given a system of the type $\dot{x}=f(x,y), \quad \dot{y}=g(x,y)$, the Jacobian is defined as the following matrix:
$$J(x,y)= \begin{bmatrix} 
    \frac{\partial{f}}{\partial{x}} &  \frac{\partial{f}}{\partial{y}} \\
    \frac{\partial{g}}{\partial{x}} & \frac{\partial{g}}{\partial{y}} \end{bmatrix} $$
For our system, the Jacobian is
$$J(X,Y)= \begin{bmatrix} 
    -\mu Y &  -\mu X \\
    \mu Y & -\mu X-\nu \end{bmatrix} $$

We then evaluate the Jacobian at our equilibrium point:
$$J(20,10)= \begin{bmatrix} 
    -0.025(10) &  -0.025(20) \\
    0.025(10) & 0.025(20)-0.5 \end{bmatrix}= \begin{bmatrix} 
    -0.25 &  -0.5 \\
    0.25 & 0 \end{bmatrix} $$
    
Our next step is to find the eigenvalues of this matrix.
\begin{equation*}
\det{\begin{bmatrix} 
    -0.25-\lambda & -0.5 \\
    0.25 & 0-\lambda \end{bmatrix}}=0 \\
\end{equation*}

$$ \left(-0.25-\lambda\right) \left(-\lambda\right)+0.125=0 $$
$$ \lambda^2+0.25\lambda +0.125=0 $$
$$\frac{-b\pm\sqrt{b^2-4ac}}{2a} \quad \longrightarrow \quad \frac{-0.25\pm\sqrt{0.0625-4(0.125)}}{2} = \frac{-0.25\pm \sqrt{-4.375}}{2} \approx -0.125 \pm 0.331\,i$$
We found complex eigenvalues with a negative real part, which means that we have a (stable) spiral sink. Near our equilibrium point, the phase portrait looks like:

```{r, echo=FALSE}
# Phase Portrait setup
y0 <- matrix(c(0, 1, 0, 5, -6, 1, 5, 0.5, 0, -3), 5, 2, byrow = TRUE)

y0_df <- tibble(x=c(0,0,-6,5,0), 
                y=c(1,5,1,0.5,-3),
                IC=c("V1", "V2", "V3", "V4", "V5")) %>% 
  mutate(pt = paste0("(",x, ",", y, ")"))

fun_traj <- function(t, y, parameters) {
  x <- y[1]
  y <- y[2]
  a <- parameters[1]
  b <- parameters[2]
  c <- parameters[3]
  d <- parameters[4]
  dy <- numeric(2)
  dy[1] <- a*x + b*y
  dy[2] <- c*x + d*y  
  return(list(dy))
}

fun_plane <- c(dx ~ a*x+b*y, dy ~c*x+d*y)

make_plane_complex <- function(params) {
  params_unnamed <- unname(params)
  traj <- trajectory(fun_traj, y0 = y0, tlim= c(0, 55), tstep = 0.05,
                     parameters = params_unnamed, add=FALSE)
  
  t <- c(traj$t)
  x <- as_tibble(traj$x) %>% bind_cols("t"=t) %>% 
    pivot_longer(cols = c(1:5), names_to = "IC", values_to = "x")
  y <- as_tibble(traj$y) %>% bind_cols("t"=t) %>% 
    pivot_longer(cols = c(1:5), names_to = "IC", values_to = "y")
  z <- left_join(x,y, by = join_by(t, IC)) %>% filter(x<7 & x>-7 & y<7 & y>-7) %>% 
    left_join(y0_df %>% select(IC, pt), by="IC")
  
  p1 <- phaseplane(fun_plane, x_var="x" ,y_var="y",
                   x_window = c(-7, 7), y_window = c(-7, 7),
                   parameters = params)
  
  p1+theme_bw()+
    geom_path(data=z, aes(x=x, y=y, group=pt), linewidth=1) +
  theme(
    axis.ticks = element_blank(),
    axis.text = element_blank()
  )
}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE,fig.keep="last",fig.height=4, fig.width=4,fig.align='center'}
make_plane_complex(c(a=-0.25,b=-0.5,c=0.25,d=0))
```
    
    
    
### b.   
Modify the model given in class, assuming that the Susceptible population exhibits exponential growth with an intrinsic growth rate of 0.10 in the absence of any infected individuals.

The differential equation for the infected population will remain the same, so we will still have
$$\frac{dY}{dt}=\mu XY- \nu Y $$
However, we need to modify our DE for the susceptible population so that in the absence of infected individuals (i.e., when $Y=0$), the population will exhibit exponential growth. We set $r=0.1$ and write our new equation as
$$\frac{dX}{dt}=-\mu XY+ rX $$
When $Y=0$, this becomes $\frac{dX}{dt}=rX$. We know this simple first-order ODE has the solution $X(t)=X_0 e^{rt}$, meaning the population will grow exponentially over time with an intrinsic growth rate of 0.1, as desired.


### c.  
Find all equilibria of your new Epidemic model from part (b) and determine their stability by sketching the phase plane near each equilibrium.

To find the equilibrium points of our new epidemic model, we need to find all of the points where 
\begin{equation}\label{eqn:dX}
\frac{dX}{dt}=-\mu XY+ rX=0
\end{equation}

\begin{equation}\label{eqn:dY}
\frac{dY}{dt}=\mu XY- \nu Y =0
\end{equation}

Let's start with the derivative of $Y$, which is the same as when we analyzed it in class. $$\frac{dY}{dt}=Y(\mu X- \nu)=0$$
This means that either $Y=0$ or $\mu X - \nu = 0$. But if $Y=0$, we must have $\frac{dX}{dt}=0+ rX=0$, and since we defined $r=0.1$, $X$ must be zero and we have found the logical but boring equilibrium point $(0,0)$.

The other possibility is $\mu X - \nu = 0$, which we can rearrange to be $X= \frac{\nu}{\mu}$. Plugging this into (\ref{eqn:dX}), we get
$$\frac{dX}{dt}=-\mu \frac{\nu}{\mu}Y+ r\frac{\nu}{\mu}=0 $$
$$\frac{dX}{dt}=-\nu Y+ r\frac{\nu}{\mu}=0 $$
$$\nu Y= r\frac{\nu}{\mu}$$
$$Y= \frac{r}{\mu}$$
Therefore, our second equilibrium point is $$\left(\frac{\nu}{\mu},\frac{r}{\mu}\right)=\left(\frac{0.5}{0.025},\frac{0.1}{0.025}\right)=(20,4)$$

Now we look at $\frac{dX}{dt}=-\mu XY+ rX= X(-\mu Y+r)=0$
Thus, either $X=0$ or $-\mu Y+r=0$. If $X=0$, our equation (\ref{eqn:dY}) says that we must have $Y=0$, so we found the same equilibrium point $(0,0)$ as before. If $-\mu Y+r=0 \quad\Rightarrow\quad \mu Y=r \quad\Rightarrow\quad Y= \frac{r}{\mu}$

$$\frac{dY}{dt}=\mu XY- \nu Y =0$$

$$\frac{dY}{dt}=\mu X \frac{r}{\mu}- \nu \frac{r}{\mu} =0$$
$$Xr- \nu \frac{r}{\mu} =0$$
We can divide by $r$ because it is a non-zero constant:
$$X- \frac{\nu}{\mu} =0$$
So we again we have the equilibrium point 
$$\left(\frac{\nu}{\mu},\frac{r}{\mu}\right)=(20,4)$$

For our new system, the Jacobian is
$$J(X,Y)= \begin{bmatrix} 
    -\mu Y + r &  -\mu X \\
    \mu Y & -\mu X-\nu \end{bmatrix}= \begin{bmatrix} 
    -\mu Y + r &  -\mu X \\
    \mu Y & -\mu X-\nu \end{bmatrix} $$

We then evaluate the Jacobian at our equilibrium point:
$$J(20,4)= \begin{bmatrix} 
    -0.025(4)+0.1 &  -0.025(20) \\
    0.025(4) & 0.025(20)-0.5 \end{bmatrix}= \begin{bmatrix} 
    0 &  -0.5 \\
    0.1 & 0 \end{bmatrix} $$

Our next step is to find the eigenvalues of this matrix.
\begin{equation*}
\det{\begin{bmatrix} 
    0-\lambda & -0.5 \\
    0.1 & 0-\lambda \end{bmatrix}}=0 \\
\end{equation*}


$$ \lambda^2+0.05=0 $$

So $\lambda \approx \pm 0.223 i$. Since we have purely imaginary complex eigenvalues, the phase plane will look like a center, corresponding to periodic solutions:
```{r, echo=FALSE, message=FALSE, warning=FALSE,fig.keep="last",fig.height=4, fig.width=4,fig.align='center'}

# Phase Portrait setup
# Phase Portrait setup
y0 <- matrix(c(0, 1, -6, 1, 5, 0.5, 0, -3), 5, 2, byrow = TRUE)

y0_df <- tibble(x=c(0,-6,5,0), 
                y=c(1,1,0.5,-3),
                IC=c("V1", "V2", "V3", "V4")) %>% 
  mutate(pt = paste0("(",x, ",", y, ")"))

fun_traj <- function(t, y, parameters) {
  x <- y[1]
  y <- y[2]
  a <- parameters[1]
  b <- parameters[2]
  c <- parameters[3]
  d <- parameters[4]
  dy <- numeric(2)
  dy[1] <- a*x + b*y
  dy[2] <- c*x + d*y  
  return(list(dy))
}

fun_plane <- c(dx ~ a*x+b*y, dy ~c*x+d*y)

make_plane_complex <- function(params) {
  params_unnamed <- unname(params)
  traj <- trajectory(fun_traj, y0 = y0, tlim= c(0, 55), tstep = 0.05,
                     parameters = params_unnamed, add=FALSE)
  
  t <- c(traj$t)
  x <- as_tibble(traj$x) %>% bind_cols("t"=t) %>% 
    pivot_longer(cols = c(1:4), names_to = "IC", values_to = "x")
  y <- as_tibble(traj$y) %>% bind_cols("t"=t) %>% 
    pivot_longer(cols = c(1:4), names_to = "IC", values_to = "y")
  z <- left_join(x,y, by = join_by(t, IC)) %>% filter(x<7 & x>-7 & y<7 & y>-7) %>% 
    left_join(y0_df %>% select(IC, pt), by="IC")
  
  p1 <- phaseplane(fun_plane, x_var="x" ,y_var="y",
                   x_window = c(-7, 7), y_window = c(-7, 7),
                   parameters = params)
  
  p1+theme_bw()+
    geom_path(data=z, aes(x=x, y=y, group=pt), linewidth=1) +
  theme(
    axis.ticks = element_blank(),
    axis.text = element_blank()
  )
}

make_plane_complex(c(a=0,b=-0.5,c=0.1,d=0))
```



We then evaluate the Jacobian at our other equilibrium point, (0,0):
$$J(0,0)= \begin{bmatrix} 
    -0.025(0)+0.1 &  -0.025(0) \\
    0.025(0) & 0.025(0)-0.5 \end{bmatrix}= \begin{bmatrix} 
    0.1 &  0 \\
   0 & -0.5 \end{bmatrix} $$

We can see that our eigenvalues for this matrix are the values along the diagonal, $\lambda_1=0.1, \; \lambda_2=-0.5$. Using our knowledge of linear algebra, we know that the eigenvector associated with $\lambda_1$ is just $\begin{bmatrix}1 \\ 0 \end{bmatrix}$ and the eigenvector associated with $\lambda_2$ is $\begin{bmatrix}1 \\ 0 \end{bmatrix}$.
We have one positive and one negative eigenvalue, which means we will have an (unstable) saddle near the equilibrium at (0,0), with straight-line solutions tending away from the origin on the x-axis (because of the positive eigenvalue) and towards the origin on the y-axis (because of the negative eigenvalue).


```{r, echo=FALSE, message=FALSE, warning=FALSE,fig.keep="last",fig.height=4, fig.width=5, fig.align='center'}
# Phase Portrait setup
y0 <- matrix(c(0.2, 1, 3, 4, -6, -1, -5, 1, 4, -3), 5, 2, byrow = TRUE)

y0_df <- tibble(x=c(0.2,3,-6,-5,4), 
                y=c(1,  4,-1,1,-3),
                IC=c("V1", "V2", "V3", "V4", "V5")) %>% 
  mutate(pt = paste0("(",x, ",", y, ")"))

make_plane <- function(params) {
  params_unnamed <- unname(params)
  traj <- trajectory(fun_traj, y0 = y0, tlim= c(0, 250), tstep=0.01,
                     parameters = params_unnamed, add=FALSE)
  
  t <- c(traj$t)
  x <- as_tibble(traj$x) %>% bind_cols("t"=t) %>% 
    pivot_longer(cols = c(1:5), names_to = "IC", values_to = "x")
  y <- as_tibble(traj$y) %>% bind_cols("t"=t) %>% 
    pivot_longer(cols = c(1:5), names_to = "IC", values_to = "y")
  z <- left_join(x,y, by = join_by(t, IC)) %>% filter(x<7 & x>-7 & y<7 & y>-7) %>% 
    left_join(y0_df %>% select(IC, pt), by="IC")
  
  p1 <- phaseplane(fun_plane, x_var="x" ,y_var="y",
                   x_window = c(-7, 7), y_window = c(-7, 7),
                   parameters = params)

  p1+theme_bw()+
    geom_vline(linewidth=1, xintercept = 0, color="gray")+
    geom_hline(linewidth=1, yintercept = 0, color="gray")+
    geom_path(data=z, aes(x=x, y=y, group=pt), linewidth=1.5)
}


make_plane(c(a=0.1,b=0,c=0,d=-0.5))

```


## Question 2   
Consider the IVP from class: $$\frac{dy}{dt}=-2ty^2, \quad y(0)=1$$ over the interval $0 \leq t \leq 2$.

### a.  
Calculate the Runge-Kutta approximation to the solution with $n=4$ steps.

Given an initial value problem $\frac{dy}{dt} = f(t, y), \quad y(t_0) = y_0$, the Runge-Kutta method is as follows:

Pick a step-size $h>0$ and define:

\begin{align*}
y_{n+1} &= y_n + \frac{h}{6}\left(k_1 + 2k_2 + 2k_3 + k_4 \right),\\
t_{n+1} &= t_n + h \\
\end{align*}

for $n = 0, 1, 2, 3, ...$ using
\begin{align*}
 k_1 &= \ f(t_n, y_n), \\
 k_2 &= \ f\!\left(t_n + \frac{h}{2}, y_n + h \frac{k_1}{2}\right), \\ 
 k_3 &= \ f\!\left(t_n + \frac{h}{2}, y_n + h \frac{k_2}{2}\right), \\
 k_4 &= \ f\!\left(t_n + h, y_n + h k_3\right).
\end{align*}

We will first compute the result manually using this process, then check our results with two different R packages:
```{r}
manual<- tribble(
  ~val,  ~n_1,        ~n_2,         ~n_3,        ~n_4,
  "t",  0.5,        1,          1.5,        2,
  "k1", 0,         -0.63740945,-0.49940322,-0.28490054,
  "t_n+h/2",0.25,       0.75,       1.25,       1.75,
  "y_n+h*(k1)/2", 1,          0.6390269,  0.37485072, 0.23694178,
  "k2",-0.5,       -0.61253307,-0.35128265,-0.19649492,
  "y_n+h*(k2)/2", 0.875,      0.64524599, 0.41188086, 0.25904318,
  "k3",-0.3828125, -0.62451359,-0.42411461,-0.2348618,
  "y_n+h*(k3)", 0.80859375, 0.48612247, 0.28764422, 0.19073601,
  "k4",-0.65382385,-0.47263011,-0.24821759,-0.14552091,
  "y",  0.79837926, 0.49970152, 0.30816691, 0.20040567)

# from manual computation of intermediate values
as.data.frame(manual)
```

```{r}
# from demodelr package
demodelr_out<- as.data.frame(demodelr::rk4(system_eq=c(dy ~ -2*t*(y^2)),
              initial_condition = c(y=1),
              deltaT = 0.5,
              n_steps = 5))
demodelr_out

# from deSolve paackage
rk_fun <- function(t, x, parms) {
  with(as.list(parms), {
    dx <- -1*a*t*(x[1])^2
    list(dx) }) }

time <- seq(from=0, to=2, length.out=5)
deSolve_out <- as.data.frame(deSolve::rk4(c(y=1), time, rk_fun, c(a=2)))
deSolve_out
```

In all three cases, we found $y(2) \approx 0.2004057$.




### b.  
Calculate the total error $e_4$ associated with this approximation.

We define the total error after $k$ steps to be
$$e_k = \lvert y(t_k)-y_k\rvert $$
Since we know the true solution to our ODE is $y(t)=\frac{1}{1+t^2}$, we know that the value of the function at $t=2$ should be $y(2)=\frac{1}{1+4}=0.2$

```{r}
rk_est <- deSolve_out %>% filter(time==2) %>% pull(y) #our rk4 approx.
abs(0.2-rk_est) #abs. difference between approx. and real values
```

Thus, RK4 with $\Delta t=0.5$ gives us $e_4 = 4.057 \times 10^{-4}$.

### c.  
How many steps are necessary to approximate the solution with an error of less than
0.0001? Make sure to justify your answer.

In class, we found that RK4 with $\Delta t=0.2$ gives us $e_{10} = 1.095 \times 10^{-5}$ and with $\Delta t=0.1$ gives us $e_{20} = 6.541 \times 10^{-7}$.

We know that
\begin{equation}\label{eqn:C}
e_n \leq C \Delta t
\end{equation},

so given the error associated with two different time steps $t_1$ and $t_2$, we have the following relationship:

$$e_{n_1} \leq C(\Delta t_1)^4, \quad e_{n_2} \leq C(\Delta t_2)^4 \quad\Longrightarrow\quad 
\frac{e_{n_1}}{e_{n_2}} \leq \left(\frac{\Delta t_1}{\Delta t_2}\right)^4 
\quad\Longrightarrow\quad 
\left(\frac{e_{n_1}}{e_{n_2}}\right)^{1/4} \leq \frac{\Delta t_1}{\Delta t_2} $$
Which we can rearrange as
$$\Delta t_1  \geq \left(\frac{e_{n_1}}{e_{n_2}}\right)^{1/4} \Delta t_2 $$

Given an interval $0 \leq t \leq T$ and a known time step $\Delta t_1$, you need $n_1=\frac{T}{\Delta t_1}$ time steps, so if we know the error $e_{n_2}$ associated with a time step $t_2$, we can find the number of steps needed to approximate a target error $e_{n_1}$ with the formula:

$$n_1  \geq \left(\frac{e_{n_1}}{e_{n_2}}\right)^{-1/4} \frac{T}{\Delta t_2} $$

We can write a function to do this in R:
```{r}
find_n <- function(e1, e2, t2, T) {
  out <- ((e1/e2)^(-1/4))*T*(1/t2)
  out
}
```

```{r}
e4<- 0.0004056722 # The error we calculated in part (b) above
e10<-1.095e-5     # From class slides
e20<- 6.541e-7    # From class slides

# Checking that our function works
test4 <- paste(round(find_n(e1=e4, e2=e10, t2=0.2, T=2),2),
      round(find_n(e1=e4, e2=e20, t2=0.1, T=2),2), sep=",")

test10<- paste(round(find_n(e1=e10, e2=e4, t2=0.5, T=2),2),
      round(find_n(e1=e10, e2=e20, t2=0.1, T=2),2), sep=",")
      
test20 <- paste(round(find_n(e1=e20, e2=e10, t2=0.2, T=2),2),
     round(find_n(e1=e20, e2=e4, t2=0.5, T=2),2), sep=",")

out <- paste(test4, test10, test20, sep="\n")
cat(out)
```
```{r}
en <- 0.0001 # Target error

# Applying the function to our target error and all three known error/time step combinations
out2 <- paste(find_n(e1=en, e2=e10, t2=0.2, T=2), 
              find_n(e1=en, e2=e20, t2=0.1, T=2),
              find_n(e1=en, e2=e4, t2=0.5, T=2), sep="\n")
cat(out2)
```


Therefore, we would need 6 time steps to approximate our solution with an error of less than 0.001.

We can see that we obtain the same result by finding $C$ directly and plugging in our values to (\ref{eqn:C}):

```{r}
c1<- 0.0004056722/(0.5)^4 #0.006490755
c2 <- 1.095e-5/(0.2)^4 #0.00684375
c3 <- 6.541e-7/(0.1)^4 #0.006541
c<- mean(c(c1, c2, c3))
2/((en/c)^(1/4))
```

